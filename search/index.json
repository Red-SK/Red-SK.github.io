[{"content":"1. 函数式数据处理 行为参数化 行为参数化是一种编程范式，它允许方法的行为通过参数的形式传递和修改。这种技术在处理变化的需求时非常有用，因为它使得代码更加灵活，能够适应不同的行为而无需修改方法本身。行为参数化是函数式编程思想在面向对象编程语言中的一种体现，特别是在Java 8中，通过使用Lambda表达式和方法引用，行为参数化变得更加简单和直观。\nLambda parameters -\u0026gt; expression 或 (parameters)-\u0026gt;{statement;}\n当 Lambda 表达式被用在一个期望 void 返回类型的上下文时,表达式的返回值会被忽略,而表达式本身会被当做一个语句来执行. 如果 Lambda 允许捕获可改变的局部变量,就会引发线程不安全的新可能性. 函数式接口 定义\n只定义一个抽象方法的接口 使用 @FunctionalInterface 注解函数式接口 只有在接受函数式接口的地方才可以使用 lambda 表达式 例子\nPredicate Predicate 通常用于过滤数据或匹配数据 1 2 3 4 @FunctionalInterface public interface Predicate\u0026lt;T\u0026gt; { boolean test(T t); } Consumer 适用于需要访问对象的操作中，比如从集合中的每个元素中提取信息或者对每个元素应用某个操作。 1 2 3 4 @FunctionalInterface public interface consumer\u0026lt;T\u0026gt; { void accept(T t); } Function Function 接口非常适用于转换数据、从一种类型映射到另一种类型的场景。 这里，@FunctionalInterface 注解表明这是一个函数式接口，而接口中的 apply 方法是要实现的抽象方法。apply 方法接受一个类型为 T 的参数，并返回一个类型为 R 的结果。 1 2 3 4 @FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; { R apply(T t); } Function接口中的compose、andThen和identity方法使得函数式编程在Java中更加强大和灵活。\nandThen\nandThen方法用于将两个Function实例串联起来，其中第一个函数的输出作为第二个函数的输入。其签名如下：\n1 default \u0026lt;V\u0026gt; Function\u0026lt;T, V\u0026gt; andThen(Function\u0026lt;? super R, ? extends V\u0026gt; after) 示例\n假设我们有两个函数，一个将字符串转换为大写，另一个计算字符串的长度：\n1 2 3 4 5 6 Function\u0026lt;String, String\u0026gt; toUpperCase = String::toUpperCase; Function\u0026lt;String, Integer\u0026gt; stringLength = String::length; Function\u0026lt;String, Integer\u0026gt; upperCaseLength = toUpperCase.andThen(stringLength); int length = upperCaseLength.apply(\u0026#34;hello world\u0026#34;); // 结果是11 compose\ncompose方法与andThen相反，它用于先执行作为参数传入的函数，然后执行调用compose的函数。其签名如下：\n1 default \u0026lt;V\u0026gt; Function\u0026lt;V, R\u0026gt; compose(Function\u0026lt;? super V, ? extends T\u0026gt; before) 示例\n使用上面相同的函数，但这次我们改用compose来实现：\n1 2 3 Function\u0026lt;String, Integer\u0026gt; upperCaseLengthCompose = stringLength.compose(toUpperCase); int lengthCompose = upperCaseLengthCompose.apply(\u0026#34;hello world\u0026#34;); // 结果仍然是11 identity\nidentity方法返回一个不进行任何操作的Function，即直接返回输入参数。这在需要传递一个原样输出的函数时非常有用。其签名如下：\n1 static \u0026lt;T\u0026gt; Function\u0026lt;T, T\u0026gt; identity() 示例\n1 2 3 Function\u0026lt;String, String\u0026gt; identityFunction = Function.identity(); String result = identityFunction.apply(\u0026#34;hello world\u0026#34;); // 结果是\u0026#34;hello world\u0026#34; 方法引用 方法引用的三种类型\n指向静态方法的方法引用 指向任意类型实例方法的方法引用 指向现有对象的实例方法的方法引用 指向静态方法的方法引用\n假设我们有一个静态方法static int findLength(String s)，它返回一个字符串的长度：\n1 2 3 4 5 public class Utils { public static int findLength(String s) { return s.length(); } } 使用Function\u0026lt;T,R\u0026gt;和方法引用：\n1 Function\u0026lt;String, Integer\u0026gt; lengthFunction = Utils::findLength; 指向任意类型实例方法的方法引用\n如果我们想引用String类的length()实例方法：\n1 Function\u0026lt;String, Integer\u0026gt; lengthFunction = String::length; 这里不需要具体的实例，我们直接通过类名引用实例方法。\n指向现有对象的实例方法的方法引用\n如果我们有一个现有的对象，比如List\u0026lt;String\u0026gt;，并想引用它的size方法：\n1 2 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;); Supplier\u0026lt;Integer\u0026gt; sizeSupplier = list::size; 这里Supplier\u0026lt;T\u0026gt;是另一个函数式接口，它不接受参数但是返回一个结果。\nStream 流只能消费一次\n流是内部迭代\n流的使用包括三件事\n一个数据源（如集合）来执行一个查询。 一个中间操作链，形成一条流的流水线。 一个终端操作，执行流水线，并生成结果 你可以利用 reduce 方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大 元素。\nfilter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才 能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所 有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。\n流有三种基本的原始类型特化：IntStream、DoubleStream 和 LongStream。它们的操 作也有相应的特化。\n流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法 创建。\n无限流是没有固定大小的流。\nJava Streams API常用操作 类别 操作 描述 筛选和切片 filter 对流中的元素进行筛选，只保留满足谓词的元素。 distinct 通过流所生成元素的 hashCode() 和 equals() 去除重复元素。 skip 跳过流中的前N个元素。 limit 截断流，使其元素不超过给定数量。 转换 map 对流中的每个元素应用函数，将其转换成其他形式或提取信息。 flatMap 将流中的每个值都换成另一个流，然后把所有流连接起来成为一个流。 查找和匹配 findFirst 返回流中的第一个元素，如果流为空，返回空的Optional。 findAny 返回流中的任意元素，如果流为空，返回空的Optional。 allMatch 检查流中的元素是否都满足给定的谓词。 noneMatch 检查流中的元素是否都不满足给定的谓词。 anyMatch 检查流中是否至少有一个元素满足给定的谓词。 归约 reduce 将流中元素反复结合起来，得到一个值。 有状态操作 sorted 流中元素按自然顺序排序或按给定的比较器排序。 distinct 通过流所生成元素的 hashCode() 和 equals() 去除重复元素。 原始类型流 IntStream, DoubleStream, LongStream 基本类型的流，提供了额外的数值计算相关的方法。 流的创建 从集合、值、数组、文件创建 流可以通过集合的 stream() 方法，Arrays.stream，以及 Files.lines 等方法创建。 iterate 和 generate 用于创建无限流。 summarizingLong、summarizingDouble summarizingLong和summarizingDouble是两个非常有用的收集器（Collectors），它们能够对流中元素的某个长整型或双精度属性进行汇总统计。这些收集器生成的是LongSummaryStatistics或DoubleSummaryStatistics实例，分别用于长整型和双精度值的统计信息，包括元素数量、总和、最小值、最大值以及平均值。\njoining joining是Java中java.util.stream.Collectors类提供的一种工厂方法，用于将流中的元素在遍历过程中合并成一个字符串。这个方法非常适合在处理字符串集合或者需要将对象转换为字符串并连接起来的情况。joining方法有几个重载版本，可以根据需要选择使用。\n1.无参版本\n当不需要在连接的字符串之间添加分隔符、前缀或后缀时，可以使用最简单的形式：\n1 public static Collector\u0026lt;CharSequence, ?, String\u0026gt; joining(CharSequence delimiter) 这将简单地将输入元素连接成一个字符串。\n示例\n1 2 3 List\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Java\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;JavaScript\u0026#34;); String result = list.stream().collect(Collectors.joining()); // 结果: \u0026#34;JavaPythonJavaScript\u0026#34; 2.带有分隔符的版本\n如果想要在每个元素之间添加一个分隔符，可以使用带有一个字符串参数的joining：\n1 public static Collector\u0026lt;CharSequence, ?, String\u0026gt; joining(CharSequence delimiter) 示例\n1 2 3 codeList\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Java\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;JavaScript\u0026#34;); String result = list.stream().collect(Collectors.joining(\u0026#34;, \u0026#34;)); // 结果: \u0026#34;Java, Python, JavaScript\u0026#34; 3.带有分隔符、前缀和后缀的版本\n最完整的joining版本允许在结果字符串的开始和结束添加前缀和后缀，同时在元素之间添加分隔符：\n1 public static Collector\u0026lt;CharSequence, ?, String\u0026gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 示例：\n1 2 3 javaCopy codeList\u0026lt;String\u0026gt; list = Arrays.asList(\u0026#34;Java\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;JavaScript\u0026#34;); String result = list.stream().collect(Collectors.joining(\u0026#34;, \u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;)); // 结果: \u0026#34;[Java, Python, JavaScript]\u0026#34; 广义的归约汇总 Collectors.reducing 工厂方法是所有这些特殊情况的一般化\n第一个参数是归约操作的起始值\n第二个参数就是转换函数\n第三个参数是累积函数\n1 int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -\u0026gt; i + j)); groupingBy 1 2 3 4 public static \u0026lt;T, K, A, D\u0026gt; Collector\u0026lt;T, ?, Map\u0026lt;K, D\u0026gt;\u0026gt; groupingBy( Function\u0026lt;? super T, ? extends K\u0026gt; classifier, Collector\u0026lt;? super T, A, D\u0026gt; downstream ) 工作原理\n分类：对流中的每个元素使用分类函数classifier，根据其返回值进行分组。这个返回值决定了元素属于哪个分组键K。 收集：对于每个分组，使用提供的下游收集器downstream对该分组中的元素进行进一步处理，生成结果类型D。 结果映射：最终，方法生成一个映射Map\u0026lt;K, D\u0026gt;，其中每个键K（分组标准）都映射到一个D类型的值（下游收集器的结果）。 Function.identity() 通过返回一个简单的恒等函数，它允许保持元素不变或作为原始形式传递，同时满足函数式接口的需求。\n1 2 3 static \u0026lt;T\u0026gt; Function\u0026lt;T, T\u0026gt; identity() { return t -\u0026gt; t; } parallel(并行流) parallel 流转换成并行流\n1 2 3 4 5 6 public static long parallelSum(long n) { return Stream.iterate(1L, i -\u0026gt; i + 1) // 从1开始生成一个无限流，每次递增1 .limit(n) // 限制流的大小为n .parallel() // 将流转换为并行流 .reduce(0L, Long::sum); // 使用reduce操作进行求和 } 流的数据源和可分解性\n类型 可分解性 ArrayList 较佳 LinkedList 差 IntStream.range 较佳 Stream.iterate 差 HashSet 好 TreeSet 好 高效使用并行流\n通过测量耗时判断是否使用\n留意装箱,自动装箱和拆箱操作会大大降低性能\nlimit 和 findFirst 等依赖于元素顺序的操作，它们在并行流上执行的代价非常大\n对于较小的数据量，选择并行流几乎从来都不是一个好的决定\n考虑终端操作中合并步骤的代价是大是小,如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升\n分支/合框架 Java 8 引入了分支/合并框架（Fork/Join Framework），这是一个用于并行执行任务的框架，旨在充分利用多核处理器的计算能力。它是一种实现了工作窃取算法（work-stealing algorithm）的框架，允许多个处理器核心更高效地处理大量任务，尤其是那些可以递归分解为更小任务的工作。\n核心概念\nFork：将一个大任务分解成若干个小任务，这些小任务可以并行执行。\u0026ldquo;Fork\u0026quot;是这个过程的术语，意味着\u0026quot;分支\u0026quot;出新的子任务。 Join：等待分支出去的任务完成，并将结果合并起来。\u0026ldquo;Join\u0026quot;指的是将这些并行执行的任务的结果合并到一起，完成整个任务。 关键组件\nForkJoinPool：这是执行ForkJoinTask任务的线程池。它使用工作窃取算法来优化任务的执行，使得所有线程都尽可能保持忙碌状态。 ForkJoinTask:这是要执行的任务的基类。有两个重要的子类： RecursiveAction：用于没有返回结果的任务。 RecursiveTask：用于有返回结果的任务。 工作窃取算法\n工作窃取算法是分支/合并框架的核心。每个处理器都有自己的任务队列。当一个处理器完成了自己队列中的所有任务后，它可以随机选择一个其他处理器，\u0026ldquo;窃取\u0026quot;一部分任务来执行。这种方法提高了线程之间的工作负载均衡，减少了闲置时间\nSpliterator Spliterator是Java 8中引入的一个接口，设计用来进一步提高并行处理能力。它在java.util包中，主要用于遍历和分割数据源，以便于进行并行计算。与Iterator相比，Spliterator提供了更多的功能，特别是对于并行迭代操作而言。\n关键方法\nSpliterator接口定义了几个关键方法：\ntryAdvance(Consumer\u0026lt;? super T\u0026gt; action)：如果剩余元素存在，则对下一个元素执行给定的操作，并返回true；否则返回false。这类似于Iterator的hasNext和next方法的结合体。 forEachRemaining(Consumer\u0026lt;? super T\u0026gt; action)：对剩余每个元素执行给定的操作，直到所有元素都被处理或操作抛出异常。 trySplit()：尝试分割此Spliterator，以便部分元素由当前Spliterator处理，而另一部分元素由新的Spliterator处理。这是并行处理的关键。 estimateSize()：返回此Spliterator中剩余元素的估计数量。 characteristics()：返回此Spliterator的特征值，这是一个位模式，表示该Spliterator的属性集。 2.高效 Java8 编程 Lambda 表达式优化代码 用Lambda表达式取代匿名类 原代码使用匿名类\n1 2 3 4 5 6 codeRunnable runnable = new Runnable() { @Override public void run() { System.out.println(\u0026#34;Running in runnable\u0026#34;); } }; 重构后使用Lambda表达式\n1 Runnable runnable = () -\u0026gt; System.out.println(\u0026#34;Running in runnable\u0026#34;); 用方法引用重构Lambda表达式 原Lambda表达式代码\n1 Consumer\u0026lt;String\u0026gt; printer = s -\u0026gt; System.out.println(s); 重构后使用方法引用\n1 Consumer\u0026lt;String\u0026gt; printer = System.out::println; 用Stream API重构命令式的数据处理 命令式编程风格（原代码）\n1 2 3 4 5 6 codeList\u0026lt;String\u0026gt; filtered = new ArrayList\u0026lt;\u0026gt;(); for(String string : strings) { if(string.startsWith(\u0026#34;J\u0026#34;)) { filtered.add(string); } } 重构后使用Stream API\n1 2 3 javaCopy codeList\u0026lt;String\u0026gt; filtered = strings.stream() .filter(s -\u0026gt; s.startsWith(\u0026#34;J\u0026#34;)) .collect(Collectors.toList()); 使用Lambda表达式改进代码封装性和可读性 如果你发现需要频繁地从客户端代码查询对象状态，仅为了调用该对象的一个方法，可以通过接收Lambda或方法引用作为参数的方式来改进。\n重构前的代码\n1 2 3 javaCopy codeif(logger.isEnabled()) { logger.log(\u0026#34;Message with \u0026#34; + parameter); } 改进后的代码\n定义一个新的日志方法，接受一个Supplier\u0026lt;String\u0026gt;类型的Lambda表达式作为参数，这样可以延迟消息构建的过程，只有在日志器启用的情况下才进行：\n1 2 3 4 5 6 // 在Logger类中添加 public void logWithCondition(Supplier\u0026lt;String\u0026gt; messageSupplier) { if (this.isEnabled()) { log(messageSupplier.get()); } } 然后客户端代码可以这样调用：\n1 2 javaCopy code logger.logWithCondition(() -\u0026gt; \u0026#34;Message with \u0026#34; + parameter); 这样，客户端代码就不需要直接查询日志器的状态了。通过将参数构建（或者说是计算）延迟到确实需要日志消息的时刻，提高了代码的封装性和可读性，同时也避免了在日志器未启用时不必要的字符串拼接操作。\n重构|调试|测试 延迟执行和环绕执行 延迟执行（Lazy Execution） 延迟执行是编程中的一种策略，其中计算或代码执行被推迟到其结果实际需要的那一刻。这种策略在处理大量数据或进行资源密集型操作时特别有用，因为它可以提高应用程序的效率和响应能力。在Java中，延迟执行常常与流（Streams）、延迟加载和懒惰初始化等概念相关联。\n环绕执行（Around Execution） 环绕执行是一种编程模式，通常用于资源管理、监控、日志记录或安全控制等场景。这种模式允许开发者在方法执行前后执行一些预处理和后处理代码，而不需要修改原有方法的代码。在Java中，环绕执行经常通过使用代理（Proxy）、装饰器模式或AOP（面向切面编程）框架如Spring AOP来实现。\nLambda 与 设计模式 策略模式 模版方法 观察者模式 责任链模式 工厂模式 peek peek 是 Stream API 中的一个中间操作，它允许你在不改变流中元素的情况下，对每个元素执行操作，主要用于调试目的，因为它允许查看流中的元素而不会干扰后续的操作。\n1 Stream\u0026lt;T\u0026gt; peek(Consumer\u0026lt;? super T\u0026gt; action) 默认方法 目的: 它让类可以自动地继承接口的一个默认实现,它让类库的设计者放心地改进应用程序接口，无需担忧对遗留代码的影响。\n三种兼容性 二进制级的兼容（Binary Compatibility）\n定义：如果一个应用程序在升级了使用的库或组件之后，不需要重新编译，仍然可以正常运行，那么这个库或组件的新版本就被认为是与旧版本在二进制级别上兼容的。 关键点：这种兼容性确保了编译后的程序代码（二进制代码）在库或组件更新后仍可运行，无需任何修改。这通常涉及到API中函数的签名、数据类型的布局和大小、以及类成员的顺序和可访问性等方面。 源代码级的兼容（Source Compatibility）\n定义：如果在库或组件更新后，应用程序的源代码不需要修改就能重新编译并正常运行，那么这个更新被认为是源代码级别上兼容的。 关键点：这种兼容性强调源代码在经历库或组件的版本升级后仍旧可以不经修改直接编译通过。它关注于API的使用方式，包括函数、类的命名，参数的类型和数量，返回值类型等。 函数行为的兼容（Functional Behavior Compatibility）\n定义：如果库或组件的功能更新后，其公开的函数或方法的行为（包括副作用、执行结果和性能特征）保持不变，那么这个更新被认为保持了函数行为的兼容。 关键点：这种兼容性确保了即使库或组件的内部实现发生变化，对外提供的功能和预期的行为没有改变。对于使用该库或组件的开发者来说，他们可以预期即便更新了依赖，其应用程序的功能表现不会受到影响。 默认方法的使用模式 可选方法 放置一个空的实现，减少无效的模版代码。\n1 2 3 4 5 6 7 interface Iterator\u0026lt;T\u0026gt; { boolean hasNext(); T next(); default void remove() { throw new UnsupportedOperationException(); } } 行为的多继承 默认方法提供了一种多重继承的行为实现机制。类可以从多个接口继承默认方法的实现，解决了之前Java中的多重继承限制。在遇到多个接口定义相同默认方法的情况下，实现类必须覆盖该方法，以解决冲突。\n方法解决冲突 类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法。 CompletableFuture CompletableFuture 提供了丰富的方法来处理异步编程的需求。以下是一些最常用的方法：\n创建方法 static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier) 异步地执行一个 Supplier 供给型函数。 static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier, Executor executor) 在指定的 Executor 中异步地执行一个 Supplier 函数。 转换和处理结果的方法 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApply(Function\u0026lt;? super T,? extends U\u0026gt; fn) 当 CompletableFuture 完成时，将结果传递给提供的函数。 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync(Function\u0026lt;? super T,? extends U\u0026gt; fn) 异步地应用一个函数到 CompletableFuture 的结果上。 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync(Function\u0026lt;? super T,? extends U\u0026gt; fn, Executor executor) 在指定的 Executor 中异步地应用一个函数到 CompletableFuture 的结果上。 消费结果的方法 CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;? super T\u0026gt; action) 当 CompletableFuture 完成时，给定的动作会被执行，消费 CompletableFuture 的结果。 CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action) 异步地消费 CompletableFuture 的结果。 CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action, Executor executor) 在指定的 Executor 中异步地消费 CompletableFuture 的结果。 组合 CompletableFuture 的方法 \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombine(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn) 当两个 CompletionStage 都正常完成时，将它们的结果传递给提供的函数。 \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombineAsync(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn) 异步地组合两个 CompletionStage 的结果，并应用函数。 \u0026lt;U,V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombineAsync(CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T,? super U,? extends V\u0026gt; fn, Executor executor) 在指定的 Executor 中异步地组合两个 CompletionStage 的结果，并应用函数。 异常处理的方法 CompletableFuture\u0026lt;T\u0026gt; exceptionally(Function\u0026lt;Throwable, ? extends T\u0026gt; fn) 当 CompletableFuture 完成异常时，提供的函数将被调用，可以返回替代的结果。 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handle(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) 当 CompletableFuture 完成时（无论正常还是异常），提供的函数都会被调用，并允许返回结果或抛出异常。 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) 异步地处理 CompletableFuture 的完成（无论正常还是异常）。 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn, Executor executor) 在指定的 Executor 中异步地处理 CompletableFuture 的完成（无论正常还是异常）。 并行——使用流还是CompletableFutures？\n如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程）。 反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。**** 新的日期和时间API LocalDate 内容：表示不带时间的日期，例如 2023-03-30。 常用API now()：获取当前日期。 of(year, month, day)：创建一个指定年月日的日期。 plusDays(long daysToAdd)、minusDays(long daysToSubtract)：日期加减操作。 getDayOfWeek()、getMonth()、getYear()：获取日期的各个部分。 LocalTime 内容：表示不带日期的时间，例如 10:15:30。 常用API now()：获取当前时间。 of(hour, minute, second)：创建一个指定时分秒的时间。 plusHours(long hoursToAdd)、minusHours(long hoursToSubtract)：时间加减操作。 getHour()、getMinute()、getSecond()：获取时间的各个部分。 Instant 内容：表示时间线上的一个瞬时点，它是以 Unix 时间戳的形式来存储的。 常用API now()：获取当前的瞬时点。 ofEpochMilli(long epochMilli)：根据 Unix 时间戳创建 Instant 实例。 plusMillis(long millisToAdd)、minusMillis(long millisToSubtract)：瞬时点的加减操作。 Duration 内容：表示两个时刻之间的时间量，以秒和纳秒为单位。 常用API between(Temporal startInclusive, Temporal endExclusive)：计算两个时间点之间的 Duration。 ofDays(long days)、ofHours(long hours)、ofMinutes(long minutes)：创建指定时间长度的 Duration。 plus(Duration duration)、minus(Duration duration)：Duration 的加减操作。 Period 内容：表示两个日期之间的年月日的时间量。 常用API between(LocalDate startDateInclusive, LocalDate endDateExclusive)：计算两个日期之间的 Period。 ofYears(int years)、ofMonths(int months)、ofDays(int days)：创建指定时间长度的 Period。 plus(Period period)、minus(Period period)：Period 的加减操作。 附录 常用的函数式接口 接口名 方法签名 用途 其他方法 Consumer\u0026lt;T\u0026gt; void accept(T t) 接受单个输入参数并且不返回结果的操作（消费者）。 N/A Supplier\u0026lt;T\u0026gt; T get() 无需输入参数，返回一个结果。 N/A Function\u0026lt;T, R\u0026gt; R apply(T t) 接受一个输入参数，返回一个结果。 default \u0026lt;V\u0026gt; Function\u0026lt;V, R\u0026gt; compose(Function\u0026lt;? super V, ? extends T\u0026gt; before)\ndefault \u0026lt;V\u0026gt; Function\u0026lt;T, V\u0026gt; andThen(Function\u0026lt;? super R, ? extends V\u0026gt; after)\nstatic \u0026lt;T\u0026gt; Function\u0026lt;T, T\u0026gt; identity() Predicate\u0026lt;T\u0026gt; boolean test(T t) 确定类型为T的对象是否满足某约束，并返回boolean值。 default Predicate\u0026lt;T\u0026gt; and(Predicate\u0026lt;? super T\u0026gt; other)\ndefault Predicate\u0026lt;T\u0026gt; negate()\ndefault Predicate\u0026lt;T\u0026gt; or(Predicate\u0026lt;? super T\u0026gt; other) BiConsumer\u0026lt;T,U\u0026gt; void accept(T t, U u) 接受两个输入参数的操作，并且不返回任何结果。 N/A BiFunction\u0026lt;T,U,R\u0026gt; R apply(T t, U u) 接受两个输入参数的函数，并且返回一个结果。 N/A UnaryOperator\u0026lt;T\u0026gt; 继承自Function 一种特殊的Function，输入参数类型和返回类型相同。 static \u0026lt;T\u0026gt; UnaryOperator\u0026lt;T\u0026gt; identity() BinaryOperator\u0026lt;T\u0026gt; 继承自BiFunction 一种特殊的BiFunction，两个输入参数和返回类型相同。 N/A Optional 类主要方法 方法名 描述 empty() 创建一个空的 Optional 实例。 of(T value) 创建一个包含非空值的 Optional 实例。如果 value 为 null，则抛出 NullPointerException。 ofNullable(T value) 创建一个 Optional 实例，如果指定的值为 null，则返回一个空的 Optional。 isPresent() 如果值存在且非空，则返回 true；否则返回 false。 isEmpty() Java 11 中引入，如果值不存在或为空，则返回 true；否则返回 false。 get() 如果值存在，则返回该值；否则抛出 NoSuchElementException。 ifPresent(Consumer\u0026lt;? super T\u0026gt; action) 如果值存在，执行给定的操作。 ifPresentOrElse(Consumer\u0026lt;? super T\u0026gt; action, Runnable emptyAction) Java 9 中引入，如果值存在，执行给定的操作；否则执行另一个操作。 orElse(T other) 如果有值则返回该值，否则返回一个默认值。 orElseGet(Supplier\u0026lt;? extends T\u0026gt; other) 如果有值则返回该值，否则返回一个由 Supplier 接口生成的值。 orElseThrow() 如果有值则返回该值，否则抛出 NoSuchElementException。 orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) 如果有值则返回该值，否则抛出由提供的 Supplier 接口生成的异常。 filter(Predicate\u0026lt;? super T\u0026gt; predicate) 如果有值且满足给定的条件，则返回包含该值的 Optional；否则返回一个空的 Optional。 map(Function\u0026lt;? super T,? extends U\u0026gt; mapper) 如果有值，则对该值执行给定的映射函数，并返回一个 Optional 类型的结果。 flatMap(Function\u0026lt;? super T, ? extends Optional\u0026lt;? extends U\u0026gt;\u0026gt; mapper) 如果有值，则将提供的 Optional 映射函数应用于该值，否则返回一个空的 Optional。 stream() Java 9 中引入，如果有值则返回仅包含该值的顺序 Stream，否则返回一个空的 Stream。 PECS原则 一个好的经验法则是所谓的PECS原则（\u0026ldquo;Producer Extends, Consumer Super\u0026rdquo;），由Joshua Bloch提出：\n如果你需要一个提供者（Producer），即希望从泛型数据类型中读取数据，使用extends。 如果你需要一个消费者（Consumer），即希望写入数据到泛型数据类型中，使用super。 ","date":"2024-03-07T00:07:56+08:00","image":"/hiwikhome/note/java8/post_huf7c4e2b6598e86764dcd35b54fe8e951_967916_120x120_fill_box_smart1_3.png","permalink":"/hiwikhome/note/java8/","title":"《Java8实战》笔记"},{"content":"Windows 常用软件 🔍 文件管理与查看 Bandizip：不仅支持ZIP、7Z、RAR等常见格式，Bandizip还提供了分卷压缩、自解压功能和多核心压缩技术，使其在文件压缩与解压缩时更加高效。更多信息 SumatraPDF：以极简主义设计著称，SumatraPDF不仅轻巧快速，还支持PDF、ePub、MOBI、XPS、DjVu、CHM、CBZ和CBR文件格式，非常适合日常文档阅读需求。更多信息 wiztree: 一款强大的磁盘空间分析工具，主要用于Windows操作系统。它能快速扫描你的硬盘驱动器，并以树状图的形式显示哪些文件和文件夹占用了最多的磁盘空间。这对于清理硬盘空间、管理文件和识别大型无用文件非常有帮助。更多信息 🧑‍💻 编程与开发 Git：是开发者协作和源代码管理的标准工具，它的分布式架构让项目版本控制更灵活、更可靠。更多信息 Python 3.10：引入了模式匹配、改进的类型注解等新特性，进一步增强了这门语言的表达力和代码的可读性。更多信息 PyCharm：提供智能代码编辑、调试、测试、版本控制集成等功能，非常适合Python开发者。更多信息 IntelliJ IDEA：专为Java开发者设计，提供深度代码分析、智能代码补全和一系列现代化工具，极大地提升开发效率。更多信息 Visual Studio Code：一个轻量级但功能强大的源代码编辑器，支持几乎所有主流的编程语言，通过海量的扩展库可定制开发环境。更多信息 🌐 网络工具 Clash for Windows：提供复杂的网络代理规则配置，支持SS、SSR、Vmess等多种代理协议，适合需要精细网络代理设置的高级用户。GitHub地址 📑 笔记与文档 Notion：集成笔记、知识库、项目管理等功能于一体，支持丰富的自定义和协作功能，适合个人和团队组织信息和任务。更多信息 Typora：提供干净的写作界面和即时渲染Markdown文档的能力，支持图片、表格、数学公式等Markdown扩展，适合需要高效写作和笔记的用户。更多信息 📐 效率工具 Everything：提供即时文件搜索能力，通过建立文件索引实现秒级搜索响应，极大地提升了文件检索效率。更多信息 UTools：通过插件扩展实现多种效率工具的集成，包括快速启动程序、搜索文件、临时笔记等，适合追求效率的现代工作者。更多信息 持续更新中\u0026hellip;..\n","date":"2024-03-03T15:10:33+08:00","image":"/hiwikhome/software/post_hu8d8bd786c26d9b7a8c17db90f956bd2b_860720_120x120_fill_box_smart1_3.png","permalink":"/hiwikhome/software/","title":"Windows 常用软件"},{"content":"🎨 前置准备 在开始部署之前，确保你的系统已经安装了以下必要的软件和工具：\nGit - 用于克隆stable-diffusion-webui的仓库。可以从Git官方下载页面下载适合你操作系统的版本。 Python 3.10.6 - stable-diffusion-webui的运行需要依赖Python。请从Python官网下载并安装Python 3.10.6版本，安装时勾选Add to PATH选项。 CUDA - 使用GPU加速，需要安装NVIDIA的CUDA工具包。具体版本和安装步骤请参考NVIDIA官方文档。 🔌 部署步骤 打开命令提示符（或终端），使用git命令克隆stable-diffusion-webui项目 1 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui clone 完成后，进入项目目录，运行webui-user.bat文件启动webui 启动成功 💽 切换镜像源 为了加快Python包的下载速度，可以切换到国内的镜像源： 1 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果你在连接时遇到网络问题，可以考虑设置网络代理 🅰 安装汉化语言包 stable-diffusion-webui支持通过扩展来安装汉化语言包，以下是具体的操作步骤：\n启动stable-diffusion-webui后，进入\u0026quot;Extensions\u0026quot;选项卡。 点击\u0026quot;Install from URL\u0026quot;，在\u0026quot;URL for extension\u0026rsquo;s git repository\u0026quot;输入框中，粘贴或输入汉化包的Git仓库地址https://github.com/VinsonLaro/stable-diffusion-webui-chinese。 点击下方的黄色\u0026quot;Install\u0026quot;按钮完成安装，随后需要重启WebUI。点击\u0026quot;Installed\u0026quot;选项，然后点击\u0026quot;Apply and restart UI\u0026quot;，最后点击网页下方的\u0026quot;Reload UI\u0026quot;完成重启。 进入\u0026quot;Settings\u0026quot;，在左侧找到\u0026quot;User interface\u0026quot;选项，在页面最下方找到\u0026quot;Localization (requires restart)\u0026quot;，选择\u0026quot;Chinese-All\u0026quot;或者\u0026quot;Chinese-English\u0026quot;。 点击页面最上方的黄色\u0026quot;Apply settings\u0026quot;按钮，然后点击右侧的\u0026quot;Reload UI\u0026quot;完成汉化。 ","date":"2024-03-03T10:05:05+08:00","image":"/hiwikhome/stable-diffusion-webui/post_hu04e5ae8a7316ec5cb02fc4b33df8089e_1251226_120x120_fill_box_smart1_3.png","permalink":"/hiwikhome/stable-diffusion-webui/","title":"stable-diffusion-webui 本地部署"},{"content":"🍤 Hugo文章创建 在Hugo中创建文章时，你可以在文章的前言（Front Matter）中定义多种属性，以控制文章的各种设置和行为。Front Matter是位于Markdown文件顶部的区域，用于存储元数据，如标题、日期、描述等。Hugo 支持 YAML、TOML 和 JSON 格式的 Front Matter。下面是一些常见属性及其说明：\n基本属性 title: 文章的标题。 date: 文章的发布日期，通常用于控制文章的排序。 draft: 布尔值，指示文章是否是草稿。如果为true，则文章在构建生产版本的站点时不会被发布。 author: 文章的作者名字。 description: 文章的简短描述，有时用于搜索引擎优化（SEO）。 分类和标签 categories: 一个列表，用于指定文章所属的分类。 tags: 一个列表，用于指定文章的标签。 URL和永久链接 slug: 文章的短链接，用于自定义文章的URL。 url: 可以完全自定义文章的URL。 高级设置 weight: 用于手动控制文章在列表中的排序。 aliases: 一个列表，用于为文章指定额外的路径，常用于重定向旧URL到新位置。 series: 用于将文章分组为系列。 图片和资源 images: 一个列表，指定文章的特色图像或相关图像。 resources: 用于管理文章附件和资源，如图片、PDF文件等。 🍧Hugo命令 Hugo 是一个快速的静态网站生成器，提供了一系列命令来帮助你创建和管理你的网站。对于本地开发，特别是想避免频繁重新编译的场景，Hugo 提供了实时重载功能，可以在你进行更改时自动重新生成网站，而无需手动重新编译。以下是一些Hugo的常用命令以及如何利用 Hugo 的实时重载功能。\nHugo常用命令 hugo：在默认情况下，运行hugo命令会生成整个网站。生成的文件会放在public目录下。 hugo server：启动一个带有实时重载功能的本地服务器。当你修改项目文件时，Hugo 会自动检测这些更改并立即重新生成静态文件，同时刷新浏览器，让你实时看到更改效果。 hugo new site [SITE_NAME]：创建一个新的Hugo网站。这会在指定的[SITE_NAME]目录下创建一个新的Hugo项目结构。 hugo new [PATH]：基于你的主题中定义的架构，创建一个新的内容文件。例如，hugo new posts/my-first-post.md会创建一个新的文章。 hugo check：运行一系列检查，以确保网站配置没有问题。 hugo version：显示当前安装的Hugo版本! 利用Hugo的实时重载功能 运行hugo server命令是开发 Hugo 网站时避免频繁重新编译的最佳实践。这个命令不仅启动了一个本地服务器，还开启了文件更改监听器，自动重新生成网站并推送更新到浏览器。\n1 2 bashCopy code hugo server 1 2 bashCopy code hugo server --bind=\u0026#34;0.0.0.0\u0026#34; --baseURL=\u0026#34;http://example.com\u0026#34; 这样，你就可以通过其他设备在同一网络中访问你的本地服务器了。\n其他有用的参数 --buildDrafts或-D：包括草稿内容在内的服务器运行。 --buildFuture：允许显示将来日期的内容。 --disableFastRender：禁用快速渲染模式，每次更改都会完全重建站点，适用于调试。 清除public 这个命令在构建网站之前会自动清理 public 目录。这意味着所有旧文件都会被删除，只有新生成的文件会被放置在 public 文件夹中。使用这个命令可以确保public目录保持最新状态\nhugo --cleanDestinationDir 通过这些命令和参数的使用，你可以高效地管理Hugo项目，并享受快速反馈的开发体验。\n🍰 Hugo 配置类 content content md文件命名用 index.md ,这样放在对应文件夹下的img才能被解析\ncategory 新增 category 时,文件夹名称与 post 中的 categories 属性应保持一致\n","date":"2024-02-27T21:54:28+08:00","image":"/hiwikhome/hugoguide/post_hu5ed620c5e0a4be7cbac7cbb3f279eaa9_3306350_120x120_fill_box_smart1_3.png","permalink":"/hiwikhome/hugoguide/","title":"Hugo 使用指南"}]