<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='1. 函数式数据处理 行为参数化 行为参数化是一种编程范式，它允许方法的行为通过参数的形式传递和修改。这种技术在处理变化的需求时非常有用，因为它使得'><title>《Java8实战》笔记</title>
<link rel=canonical href=/hiwikhome/note/java8/><link rel=stylesheet href=/scss/style.min.77cb21ae5a34f69a930740b845162008dae4d682e212d21cb2ba9cb0e199ca7b.css><meta property='og:title' content='《Java8实战》笔记'><meta property='og:description' content='1. 函数式数据处理 行为参数化 行为参数化是一种编程范式，它允许方法的行为通过参数的形式传递和修改。这种技术在处理变化的需求时非常有用，因为它使得'><meta property='og:url' content='/hiwikhome/note/java8/'><meta property='og:site_name' content='HiwiK'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='java'><meta property='article:tag' content='note'><meta property='article:published_time' content='2024-03-07T00:07:56+08:00'><meta property='article:modified_time' content='2024-03-07T00:07:56+08:00'><meta property='og:image' content='/hiwikhome/note/java8/post.png'><meta name=twitter:title content="《Java8实战》笔记"><meta name=twitter:description content="1. 函数式数据处理 行为参数化 行为参数化是一种编程范式，它允许方法的行为通过参数的形式传递和修改。这种技术在处理变化的需求时非常有用，因为它使得"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='/hiwikhome/note/java8/post.png'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><div id=article-toolbar style=position:sticky;top:5px;z-index:1000><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span></a></div><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#行为参数化>行为参数化</a></li><li><a href=#lambda>Lambda</a></li><li><a href=#函数式接口>函数式接口</a><ol><li><a href=#predicate>Predicate</a></li><li><a href=#consumer>Consumer</a></li><li><a href=#function>Function</a></li></ol></li><li><a href=#方法引用>方法引用</a></li><li><a href=#stream>Stream</a><ol><li><a href=#java-streams-api常用操作>Java Streams API常用操作</a></li><li><a href=#summarizinglongsummarizingdouble>summarizingLong、summarizingDouble</a></li><li><a href=#joining>joining</a></li><li><a href=#广义的归约汇总>广义的归约汇总</a></li><li><a href=#groupingby>groupingBy</a></li><li><a href=#functionidentity>Function.identity()</a></li></ol></li><li><a href=#parallel并行流>parallel(并行流)</a></li><li><a href=#分支合框架>分支/合框架</a></li><li><a href=#spliterator>Spliterator</a></li></ol><ol><li><a href=#lambda-表达式优化代码><strong>Lambda 表达式优化代码</strong></a><ol><li><a href=#用lambda表达式取代匿名类>用Lambda表达式取代匿名类</a></li><li><a href=#用方法引用重构lambda表达式><strong>用方法引用重构Lambda表达式</strong></a></li><li><a href=#用stream-api重构命令式的数据处理>用Stream API重构命令式的数据处理</a></li><li><a href=#使用lambda表达式改进代码封装性和可读性>使用Lambda表达式改进代码封装性和可读性</a></li></ol></li><li><a href=#重构调试测试>重构|调试|测试</a><ol><li><a href=#延迟执行和环绕执行>延迟执行和环绕执行</a></li><li><a href=#lambda-与-设计模式>Lambda 与 设计模式</a></li><li><a href=#peek>peek</a></li></ol></li><li><a href=#默认方法>默认方法</a><ol><li><a href=#三种兼容性><strong>三种兼容性</strong></a></li><li><a href=#默认方法的使用模式>默认方法的使用模式</a></li><li><a href=#方法解决冲突>方法解决冲突</a></li></ol></li><li><a href=#completablefuture>CompletableFuture</a><ol><li><a href=#创建方法>创建方法</a></li><li><a href=#转换和处理结果的方法>转换和处理结果的方法</a></li><li><a href=#消费结果的方法>消费结果的方法</a></li><li><a href=#组合-completablefuture-的方法>组合 CompletableFuture 的方法</a></li><li><a href=#异常处理的方法>异常处理的方法</a></li></ol></li><li><a href=#新的日期和时间api>新的日期和时间API</a><ol><li><a href=#localdate>LocalDate</a></li><li><a href=#localtime>LocalTime</a></li><li><a href=#instant>Instant</a></li><li><a href=#duration>Duration</a></li><li><a href=#period>Period</a></li></ol></li></ol><ol><li><a href=#常用的函数式接口>常用的函数式接口</a></li><li><a href=#optional-类主要方法>Optional 类主要方法</a></li><li><a href=#pecs原则>PECS原则</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/hiwikhome/note/java8/><img src=/hiwikhome/note/java8/post_huf7c4e2b6598e86764dcd35b54fe8e951_967916_800x0_resize_box_3.png srcset="/hiwikhome/note/java8/post_huf7c4e2b6598e86764dcd35b54fe8e951_967916_800x0_resize_box_3.png 800w, /hiwikhome/note/java8/post_huf7c4e2b6598e86764dcd35b54fe8e951_967916_1600x0_resize_box_3.png 1600w" width=800 height=309 loading=lazy alt="Featured image of post 《Java8实战》笔记"></a></div><div class=article-details><header class=article-category><a href=/categories/note/>Note</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/hiwikhome/note/java8/>《Java8实战》笔记</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-03-07</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 19 分钟</time></div></footer></div></header><section class=article-content><h1 id=1-函数式数据处理>1. 函数式数据处理</h1><h2 id=行为参数化>行为参数化</h2><p>行为参数化是一种编程范式，它允许方法的行为通过参数的形式传递和修改。这种技术在处理变化的需求时非常有用，因为它使得代码更加灵活，能够适应不同的行为而无需修改方法本身。行为参数化是函数式编程思想在面向对象编程语言中的一种体现，特别是在Java 8中，通过使用Lambda表达式和方法引用，行为参数化变得更加简单和直观。</p><h2 id=lambda>Lambda</h2><p><code>parameters -> expression</code> 或 <code>(parameters)->{statement;}</code></p><ul><li>当 Lambda 表达式被用在一个期望 <code>void</code> 返回类型的上下文时,表达式的返回值会被忽略,而表达式本身会被当做一个语句来执行.</li><li>如果 Lambda 允许捕获可改变的局部变量,就会引发线程不安全的新可能性.</li></ul><h2 id=函数式接口>函数式接口</h2><p><strong>定义</strong></p><ul><li>只定义一个抽象方法的接口</li><li>使用 <code>@FunctionalInterface</code> 注解函数式接口</li><li>只有在接受函数式接口的地方才可以使用 lambda 表达式</li></ul><p><strong>例子</strong></p><h3 id=predicate>Predicate</h3><ul><li>Predicate 通常用于<strong>过滤数据</strong>或<strong>匹配数据</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Predicate</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=nf>test</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=consumer>Consumer</h3><ul><li>适用于需要访问对象的操作中，比如从集合中的每个元素中提取信息或者对每个元素<strong>应用某个操作</strong>。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>consumer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>accept</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=function>Function</h3><ul><li><code>Function</code> 接口非常适用于转换数据、<strong>从一种类型映射到另一种类型</strong>的场景。</li><li>这里，<code>@FunctionalInterface</code> 注解表明这是一个函数式接口，而接口中的 <code>apply</code> 方法是要实现的抽象方法。<code>apply</code> 方法接受一个类型为 <code>T</code> 的参数，并返回一个类型为 <code>R</code> 的结果。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@FunctionalInterface</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>R</span><span class=w> </span><span class=nf>apply</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>Function</code>接口中的<code>compose</code>、<code>andThen</code>和<code>identity</code>方法使得函数式编程在Java中更加强大和灵活。</p><p><strong>andThen</strong></p><p><code>andThen</code>方法用于将两个<code>Function</code>实例串联起来，其中第一个函数的输出作为第二个函数的输入。其签名如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>default</span><span class=w> </span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=nf>andThen</span><span class=p>(</span><span class=n>Function</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>super</span><span class=w> </span><span class=n>R</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>after</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>示例</p><p>假设我们有两个函数，一个将字符串转换为大写，另一个计算字符串的长度：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>toUpperCase</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>String</span><span class=p>::</span><span class=n>toUpperCase</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>stringLength</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>String</span><span class=p>::</span><span class=n>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>upperCaseLength</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>toUpperCase</span><span class=p>.</span><span class=na>andThen</span><span class=p>(</span><span class=n>stringLength</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>length</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>upperCaseLength</span><span class=p>.</span><span class=na>apply</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// 结果是11</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>compose</strong></p><p><code>compose</code>方法与<code>andThen</code>相反，它用于先执行作为参数传入的函数，然后执行调用<code>compose</code>的函数。其签名如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>default</span><span class=w> </span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>Function</span><span class=o>&lt;</span><span class=n>V</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=w> </span><span class=nf>compose</span><span class=p>(</span><span class=n>Function</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>super</span><span class=w> </span><span class=n>V</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>before</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>示例</p><p>使用上面相同的函数，但这次我们改用<code>compose</code>来实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>upperCaseLengthCompose</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stringLength</span><span class=p>.</span><span class=na>compose</span><span class=p>(</span><span class=n>toUpperCase</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>lengthCompose</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>upperCaseLengthCompose</span><span class=p>.</span><span class=na>apply</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// 结果仍然是11</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>identity</strong></p><p><code>identity</code>方法返回一个不进行任何操作的<code>Function</code>，即直接返回输入参数。这在需要传递一个原样输出的函数时非常有用。其签名如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nf>identity</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>示例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>identityFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Function</span><span class=p>.</span><span class=na>identity</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>identityFunction</span><span class=p>.</span><span class=na>apply</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>);</span><span class=w> </span><span class=c1>// 结果是&#34;hello world&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=方法引用>方法引用</h2><p>方法引用的三种类型</p><ul><li>指向静态方法的方法引用</li><li>指向任意类型实例方法的方法引用</li><li>指向现有对象的实例方法的方法引用</li></ul><ol><li><p><strong>指向静态方法的方法引用</strong></p><p>假设我们有一个静态方法<code>static int findLength(String s)</code>，它返回一个字符串的长度：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Utils</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>findLength</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>length</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>使用<code>Function&lt;T,R></code>和方法引用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>lengthFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Utils</span><span class=p>::</span><span class=n>findLength</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>指向任意类型实例方法的方法引用</strong></p><p>如果我们想引用<code>String</code>类的<code>length()</code>实例方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Function</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>lengthFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>String</span><span class=p>::</span><span class=n>length</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里不需要具体的实例，我们直接通过类名引用实例方法。</p></li><li><p><strong>指向现有对象的实例方法的方法引用</strong></p><p>如果我们有一个现有的对象，比如<code>List&lt;String></code>，并想引用它的<code>size</code>方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;apple&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;banana&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;cherry&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>sizeSupplier</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list</span><span class=p>::</span><span class=n>size</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里<code>Supplier&lt;T></code>是另一个函数式接口，它不接受参数但是返回一个结果。</p></li></ol><h2 id=stream>Stream</h2><ul><li><p>流只能消费一次</p></li><li><p>流是内部迭代</p></li><li><p>流的使用包括三件事</p><ul><li>一个数据源（如集合）来执行一个查询。</li><li>一个中间操作链，形成一条流的流水线。</li><li>一个终端操作，执行流水线，并生成结果</li></ul></li><li><p>你可以利用 <code>reduce</code> 方法将流中所有的元素<strong>迭代合并</strong>成一个结果，例如求和或查找最大
元素。</p></li><li><p>filter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才
能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所
有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。</p></li><li><p>流有三种基本的原始类型特化：<code>IntStream</code>、<code>DoubleStream</code> 和 <code>LongStream</code>。它们的操
作也有相应的特化。</p></li><li><p>流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法
创建。</p></li><li><p>无限流是没有固定大小的流。</p></li></ul><h3 id=java-streams-api常用操作>Java Streams API常用操作</h3><div class=table-wrapper><table><thead><tr><th>类别</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>筛选和切片</td><td><code>filter</code></td><td>对流中的元素进行筛选，只保留满足谓词的元素。</td></tr><tr><td></td><td><code>distinct</code></td><td>通过流所生成元素的 hashCode() 和 equals() 去除重复元素。</td></tr><tr><td></td><td><code>skip</code></td><td>跳过流中的前N个元素。</td></tr><tr><td></td><td><code>limit</code></td><td>截断流，使其元素不超过给定数量。</td></tr><tr><td>转换</td><td><code>map</code></td><td>对流中的每个元素应用函数，将其转换成其他形式或提取信息。</td></tr><tr><td></td><td><code>flatMap</code></td><td>将流中的每个值都换成另一个流，然后把所有流连接起来成为一个流。</td></tr><tr><td>查找和匹配</td><td><code>findFirst</code></td><td>返回流中的第一个元素，如果流为空，返回空的Optional。</td></tr><tr><td></td><td><code>findAny</code></td><td>返回流中的任意元素，如果流为空，返回空的Optional。</td></tr><tr><td></td><td><code>allMatch</code></td><td>检查流中的元素是否都满足给定的谓词。</td></tr><tr><td></td><td><code>noneMatch</code></td><td>检查流中的元素是否都不满足给定的谓词。</td></tr><tr><td></td><td><code>anyMatch</code></td><td>检查流中是否至少有一个元素满足给定的谓词。</td></tr><tr><td>归约</td><td><code>reduce</code></td><td>将流中元素反复结合起来，得到一个值。</td></tr><tr><td>有状态操作</td><td><code>sorted</code></td><td>流中元素按自然顺序排序或按给定的比较器排序。</td></tr><tr><td></td><td><code>distinct</code></td><td>通过流所生成元素的 hashCode() 和 equals() 去除重复元素。</td></tr><tr><td>原始类型流</td><td><code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code></td><td>基本类型的流，提供了额外的数值计算相关的方法。</td></tr><tr><td>流的创建</td><td>从集合、值、数组、文件创建</td><td>流可以通过集合的 stream() 方法，Arrays.stream，以及 Files.lines 等方法创建。</td></tr><tr><td></td><td><code>iterate</code> 和 <code>generate</code></td><td>用于创建无限流。</td></tr></tbody></table></div><h3 id=summarizinglongsummarizingdouble>summarizingLong、summarizingDouble</h3><p><code>summarizingLong</code>和<code>summarizingDouble</code>是两个非常有用的收集器（Collectors），它们能够对流中元素的某个长整型或双精度属性进行汇总统计。这些收集器生成的是<code>LongSummaryStatistics</code>或<code>DoubleSummaryStatistics</code>实例，分别用于长整型和双精度值的统计信息，包括元素数量、总和、最小值、最大值以及平均值。</p><h3 id=joining>joining</h3><p><code>joining</code>是Java中<code>java.util.stream.Collectors</code>类提供的一种工厂方法，用于将流中的元素在遍历过程中合并成一个字符串。这个方法非常适合在处理字符串集合或者需要将对象转换为字符串并连接起来的情况。<code>joining</code>方法有几个重载版本，可以根据需要选择使用。</p><p><strong>1.无参版本</strong></p><p>当不需要在连接的字符串之间添加分隔符、前缀或后缀时，可以使用最简单的形式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Collector</span><span class=o>&lt;</span><span class=n>CharSequence</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>joining</span><span class=p>(</span><span class=n>CharSequence</span><span class=w> </span><span class=n>delimiter</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这将简单地将输入元素连接成一个字符串。</p><p><strong>示例</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;Java&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Python&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;JavaScript&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list</span><span class=p>.</span><span class=na>stream</span><span class=p>().</span><span class=na>collect</span><span class=p>(</span><span class=n>Collectors</span><span class=p>.</span><span class=na>joining</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 结果: &#34;JavaPythonJavaScript&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>2.带有分隔符的版本</strong></p><p>如果想要在每个元素之间添加一个分隔符，可以使用带有一个字符串参数的<code>joining</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Collector</span><span class=o>&lt;</span><span class=n>CharSequence</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>joining</span><span class=p>(</span><span class=n>CharSequence</span><span class=w> </span><span class=n>delimiter</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>示例</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>codeList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;Java&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;Python&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;JavaScript&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list</span><span class=p>.</span><span class=na>stream</span><span class=p>().</span><span class=na>collect</span><span class=p>(</span><span class=n>Collectors</span><span class=p>.</span><span class=na>joining</span><span class=p>(</span><span class=s>&#34;, &#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 结果: &#34;Java, Python, JavaScript&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>3.带有分隔符、前缀和后缀的版本</strong></p><p>最完整的<code>joining</code>版本允许在结果字符串的开始和结束添加前缀和后缀，同时在元素之间添加分隔符：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Collector</span><span class=o>&lt;</span><span class=n>CharSequence</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>joining</span><span class=p>(</span><span class=n>CharSequence</span><span class=w> </span><span class=n>delimiter</span><span class=p>,</span><span class=w> </span><span class=n>CharSequence</span><span class=w> </span><span class=n>prefix</span><span class=p>,</span><span class=w> </span><span class=n>CharSequence</span><span class=w> </span><span class=n>suffix</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>示例：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>javaCopy codeList&lt;String&gt; list = Arrays.asList(&#34;Java&#34;, &#34;Python&#34;, &#34;JavaScript&#34;);
</span></span><span class=line><span class=cl>String result = list.stream().collect(Collectors.joining(&#34;, &#34;, &#34;[&#34;, &#34;]&#34;));
</span></span><span class=line><span class=cl>// 结果: &#34;[Java, Python, JavaScript]&#34;
</span></span></code></pre></td></tr></table></div></div><h3 id=广义的归约汇总>广义的归约汇总</h3><p><code>Collectors.reducing</code> 工厂方法是所有这些特殊情况的一般化</p><ul><li><p>第一个参数是归约操作的<strong>起始值</strong></p></li><li><p>第二个参数就是<strong>转换函数</strong></p></li><li><p>第三个参数是<strong>累积函数</strong></p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=n>totalCalories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>menu</span><span class=p>.</span><span class=na>stream</span><span class=p>().</span><span class=na>collect</span><span class=p>(</span><span class=n>reducing</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>Dish</span><span class=p>::</span><span class=n>getCalories</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>j</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=/hiwikhome/note/java8/image1.png width=1188 height=439 srcset="/hiwikhome/note/java8/image1_huaca5ecaeefefbf61af28df157553ff1c_68933_480x0_resize_box_3.png 480w, /hiwikhome/note/java8/image1_huaca5ecaeefefbf61af28df157553ff1c_68933_1024x0_resize_box_3.png 1024w" loading=lazy alt=image-20240303223940506 class=gallery-image data-flex-grow=270 data-flex-basis=649px></p><h3 id=groupingby>groupingBy</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>D</span><span class=o>&gt;</span><span class=w> </span><span class=n>Collector</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=p>,</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>K</span><span class=p>,</span><span class=w> </span><span class=n>D</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=nf>groupingBy</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Function</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>super</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>K</span><span class=o>&gt;</span><span class=w> </span><span class=n>classifier</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Collector</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>super</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>D</span><span class=o>&gt;</span><span class=w> </span><span class=n>downstream</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>工作原理</strong></p><ol><li><strong>分类</strong>：对流中的每个元素使用分类函数<code>classifier</code>，根据其返回值进行分组。这个返回值决定了元素属于哪个分组键<code>K</code>。</li><li><strong>收集</strong>：对于每个分组，使用提供的下游收集器<code>downstream</code>对该分组中的元素进行进一步处理，生成结果类型<code>D</code>。</li><li><strong>结果映射</strong>：最终，方法生成一个映射<code>Map&lt;K, D></code>，其中每个键<code>K</code>（分组标准）都映射到一个<code>D</code>类型的值（下游收集器的结果）。</li></ol><h3 id=functionidentity>Function.identity()</h3><p>通过返回一个简单的恒等函数，它允许保持元素不变或作为原始形式传递，同时满足函数式接口的需求。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Function</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nf>identity</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=parallel并行流>parallel(并行流)</h2><p><code>parallel</code> 流转换成并行流</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JAVA data-lang=JAVA><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=nf>parallelSum</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>Stream</span><span class=p>.</span><span class=na>iterate</span><span class=p>(</span><span class=n>1L</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=c1>// 从1开始生成一个无限流，每次递增1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>limit</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=w>                         </span><span class=c1>// 限制流的大小为n</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>parallel</span><span class=p>()</span><span class=w>                       </span><span class=c1>// 将流转换为并行流</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=na>reduce</span><span class=p>(</span><span class=n>0L</span><span class=p>,</span><span class=w> </span><span class=n>Long</span><span class=p>::</span><span class=n>sum</span><span class=p>);</span><span class=w>           </span><span class=c1>// 使用reduce操作进行求和</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>流的数据源和可分解性</strong></p><div class=table-wrapper><table><thead><tr><th>类型</th><th>可分解性</th></tr></thead><tbody><tr><td>ArrayList</td><td>较佳</td></tr><tr><td>LinkedList</td><td>差</td></tr><tr><td>IntStream.range</td><td>较佳</td></tr><tr><td>Stream.iterate</td><td>差</td></tr><tr><td>HashSet</td><td>好</td></tr><tr><td>TreeSet</td><td>好</td></tr></tbody></table></div><p><strong>高效使用并行流</strong></p><ul><li><p>通过测量耗时判断是否使用</p></li><li><p>留意装箱,自动装箱和拆箱操作会大大降低性能</p></li><li><p><code>limit</code> 和 <code>findFirst</code> 等依赖于元素顺序的操作，它们在并行流上执行的代价非常大</p></li><li><p>对于较小的数据量，选择并行流几乎从来都不是一个好的决定</p></li><li><p>考虑终端操作中合并步骤的代价是大是小,如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升</p></li></ul><h2 id=分支合框架>分支/合框架</h2><blockquote><p>Java 8 引入了分支/合并框架（Fork/Join Framework），这是一个用于并行执行任务的框架，旨在充分利用多核处理器的计算能力。它是一种实现了工作窃取算法（work-stealing algorithm）的框架，允许多个处理器核心更高效地处理大量任务，尤其是那些可以递归分解为更小任务的工作。</p></blockquote><p><strong>核心概念</strong></p><ul><li><strong>Fork</strong>：将一个大任务分解成若干个小任务，这些小任务可以并行执行。&ldquo;Fork"是这个过程的术语，意味着"分支"出新的子任务。</li><li><strong>Join</strong>：等待分支出去的任务完成，并将结果合并起来。&ldquo;Join"指的是将这些并行执行的任务的结果合并到一起，完成整个任务。</li></ul><p><strong>关键组件</strong></p><ul><li><strong>ForkJoinPool</strong>：这是执行ForkJoinTask任务的线程池。它使用工作窃取算法来优化任务的执行，使得所有线程都尽可能保持忙碌状态。</li><li><strong>ForkJoinTask</strong>:这是要执行的任务的基类。有两个重要的子类：<ul><li><strong>RecursiveAction</strong>：用于没有返回结果的任务。</li><li><strong>RecursiveTask<v></strong>：用于有返回结果的任务。</li></ul></li></ul><p><strong>工作窃取算法</strong></p><p>工作窃取算法是分支/合并框架的核心。每个处理器都有自己的任务队列。当一个处理器完成了自己队列中的所有任务后，它可以随机选择一个其他处理器，&ldquo;窃取"一部分任务来执行。这种方法提高了线程之间的工作负载均衡，减少了闲置时间</p><h2 id=spliterator>Spliterator</h2><blockquote><p><code>Spliterator</code>是Java 8中引入的一个接口，设计用来进一步提高并行处理能力。它在<code>java.util</code>包中，主要用于遍历和分割数据源，以便于进行并行计算。与<code>Iterator</code>相比，<code>Spliterator</code>提供了更多的功能，特别是对于并行迭代操作而言。</p></blockquote><p>关键方法</p><p><code>Spliterator</code>接口定义了几个关键方法：</p><ul><li><strong>tryAdvance(Consumer&lt;? super T> action)</strong>：如果剩余元素存在，则对下一个元素执行给定的操作，并返回<code>true</code>；否则返回<code>false</code>。这类似于<code>Iterator</code>的<code>hasNext</code>和<code>next</code>方法的结合体。</li><li><strong>forEachRemaining(Consumer&lt;? super T> action)</strong>：对剩余每个元素执行给定的操作，直到所有元素都被处理或操作抛出异常。</li><li><strong>trySplit()</strong>：尝试分割此<code>Spliterator</code>，以便部分元素由当前<code>Spliterator</code>处理，而另一部分元素由新的<code>Spliterator</code>处理。这是并行处理的关键。</li><li><strong>estimateSize()</strong>：返回此<code>Spliterator</code>中剩余元素的估计数量。</li><li><strong>characteristics()</strong>：返回此<code>Spliterator</code>的特征值，这是一个位模式，表示该<code>Spliterator</code>的属性集。</li></ul><h1 id=2高效-java8-编程>2.高效 Java8 编程</h1><h2 id=lambda-表达式优化代码><strong>Lambda 表达式优化代码</strong></h2><h3 id=用lambda表达式取代匿名类>用Lambda表达式取代匿名类</h3><p><strong>原代码使用匿名类</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JAVA data-lang=JAVA><span class=line><span class=cl><span class=n>codeRunnable</span><span class=w> </span><span class=n>runnable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Running in runnable&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>重构后使用Lambda表达式</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-JAVA data-lang=JAVA><span class=line><span class=cl><span class=n>Runnable</span><span class=w> </span><span class=n>runnable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Running in runnable&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=用方法引用重构lambda表达式><strong>用方法引用重构Lambda表达式</strong></h3><p><strong>原Lambda表达式代码</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>Consumer</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span> <span class=nx>printer</span> <span class=o>=</span> <span class=nx>s</span> <span class=o>-&gt;</span> <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>重构后使用方法引用</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Consumer&lt;String&gt; printer = System.out::println;
</span></span></code></pre></td></tr></table></div></div><h3 id=用stream-api重构命令式的数据处理>用Stream API重构命令式的数据处理</h3><p><strong>命令式编程风格（原代码）</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>codeList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>filtered</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>strings</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>if</span><span class=p>(</span><span class=n>string</span><span class=p>.</span><span class=na>startsWith</span><span class=p>(</span><span class=s>&#34;J&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>filtered</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>string</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>重构后使用Stream API</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>javaCopy</span><span class=w> </span><span class=n>codeList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>filtered</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>strings</span><span class=p>.</span><span class=na>stream</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>.</span><span class=na>filter</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>startsWith</span><span class=p>(</span><span class=s>&#34;J&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>.</span><span class=na>collect</span><span class=p>(</span><span class=n>Collectors</span><span class=p>.</span><span class=na>toList</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=使用lambda表达式改进代码封装性和可读性>使用Lambda表达式改进代码封装性和可读性</h3><p>如果你发现需要频繁地从客户端代码查询对象状态，仅为了调用该对象的一个方法，可以通过接收Lambda或方法引用作为参数的方式来改进。</p><p><strong>重构前的代码</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>javaCopy</span><span class=w> </span><span class=nf>codeif</span><span class=p>(</span><span class=n>logger</span><span class=p>.</span><span class=na>isEnabled</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>logger</span><span class=p>.</span><span class=na>log</span><span class=p>(</span><span class=s>&#34;Message with &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>parameter</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>改进后的代码</strong></p><p>定义一个新的日志方法，接受一个<code>Supplier&lt;String></code>类型的Lambda表达式作为参数，这样可以延迟消息构建的过程，只有在日志器启用的情况下才进行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 在Logger类中添加</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>logWithCondition</span><span class=p>(</span><span class=n>Supplier</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>messageSupplier</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>isEnabled</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>log</span><span class=p>(</span><span class=n>messageSupplier</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>然后客户端代码可以这样调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>javaCopy code
</span></span><span class=line><span class=cl>logger.logWithCondition(() -&gt; &#34;Message with &#34; + parameter);
</span></span></code></pre></td></tr></table></div></div><p>这样，客户端代码就不需要直接查询日志器的状态了。通过将参数构建（或者说是计算）延迟到确实需要日志消息的时刻，提高了代码的封装性和可读性，同时也避免了在日志器未启用时不必要的字符串拼接操作。</p><h2 id=重构调试测试>重构|调试|测试</h2><h3 id=延迟执行和环绕执行>延迟执行和环绕执行</h3><p><strong>延迟执行（Lazy Execution）</strong>
延迟执行是编程中的一种策略，其中计算或代码执行被推迟到其结果实际需要的那一刻。这种策略在处理大量数据或进行资源密集型操作时特别有用，因为它可以提高应用程序的效率和响应能力。在Java中，延迟执行常常与流（Streams）、延迟加载和懒惰初始化等概念相关联。</p><p><strong>环绕执行（Around Execution）</strong>
环绕执行是一种编程模式，通常用于资源管理、监控、日志记录或安全控制等场景。这种模式允许开发者在方法执行前后执行一些预处理和后处理代码，而不需要修改原有方法的代码。在Java中，环绕执行经常通过使用代理（Proxy）、装饰器模式或AOP（面向切面编程）框架如Spring AOP来实现。</p><h3 id=lambda-与-设计模式>Lambda 与 设计模式</h3><ul><li>策略模式</li><li>模版方法</li><li>观察者模式</li><li>责任链模式</li><li>工厂模式</li></ul><h3 id=peek>peek</h3><p><code>peek</code> 是 <code>Stream</code> API 中的一个中间操作，它允许你在不改变流中元素的情况下，对每个元素执行操作，主要用于调试目的，因为它允许查看流中的元素而不会干扰后续的操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Stream</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nf>peek</span><span class=p>(</span><span class=n>Consumer</span><span class=o>&lt;?</span><span class=w> </span><span class=kd>super</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>action</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=默认方法>默认方法</h2><blockquote><p>目的: 它让类可以自动地继承接口的一个默认实现,它让类库的设计者放心地改进应用程序接口，无需担忧对遗留代码的影响。</p></blockquote><h3 id=三种兼容性><strong>三种兼容性</strong></h3><p><strong>二进制级的兼容（Binary Compatibility）</strong></p><ul><li><strong>定义</strong>：如果一个应用程序在升级了使用的库或组件之后，<strong>不需要重新编译</strong>，仍然可以正常运行，那么这个库或组件的新版本就被认为是与旧版本在二进制级别上兼容的。</li><li><strong>关键点</strong>：这种兼容性确保了编译后的程序代码（二进制代码）在库或组件更新后仍可运行，无需任何修改。这通常涉及到API中函数的签名、数据类型的布局和大小、以及类成员的顺序和可访问性等方面。</li></ul><p><strong>源代码级的兼容（Source Compatibility）</strong></p><ul><li><strong>定义</strong>：如果在库或组件更新后，应用程序的<strong>源代码不需要修改就能重新编译</strong>并正常运行，那么这个更新被认为是源代码级别上兼容的。</li><li><strong>关键点</strong>：这种兼容性强调源代码在经历库或组件的版本升级后仍旧可以不经修改直接编译通过。它关注于API的使用方式，包括函数、类的命名，参数的类型和数量，返回值类型等。</li></ul><p><strong>函数行为的兼容（Functional Behavior Compatibility）</strong></p><ul><li><strong>定义</strong>：如果库或组件的功能更新后，其公开的函数或方法的行为（包括副作用、执行结果和性能特征）保持不变，那么这个更新被认为保持了函数行为的兼容。</li><li><strong>关键点</strong>：这种兼容性确保了即使库或组件的内部实现发生变化，对外提供的功能和预期的行为没有改变。对于使用该库或组件的开发者来说，他们可以预期即便更新了依赖，其应用程序的功能表现不会受到影响。</li></ul><h3 id=默认方法的使用模式>默认方法的使用模式</h3><ol><li><strong>可选方法</strong></li></ol><p>放置一个空的实现，减少无效的模版代码。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=kd>interface</span> <span class=nc>Iterator</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>boolean</span><span class=w> </span><span class=nf>hasNext</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>T</span><span class=w> </span><span class=nf>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>default</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>remove</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>UnsupportedOperationException</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li><strong>行为的多继承</strong></li></ol><p>默认方法提供了一种多重继承的行为实现机制。类可以从多个接口继承默认方法的实现，解决了之前Java中的多重继承限制。在遇到多个接口定义相同默认方法的情况下，实现类必须覆盖该方法，以解决冲突。</p><h3 id=方法解决冲突>方法解决冲突</h3><ol><li>类中的方法优先级最高。类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</li><li>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体。</li><li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法。</li></ol><h2 id=completablefuture>CompletableFuture</h2><p>CompletableFuture 提供了丰富的方法来处理异步编程的需求。以下是一些最常用的方法：</p><h3 id=创建方法>创建方法</h3><ul><li><code>static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier)</code><ul><li>异步地执行一个 Supplier 供给型函数。</li></ul></li><li><code>static &lt;U> CompletableFuture&lt;U> supplyAsync(Supplier&lt;U> supplier, Executor executor)</code><ul><li>在指定的 Executor 中异步地执行一个 Supplier 函数。</li></ul></li></ul><h3 id=转换和处理结果的方法>转换和处理结果的方法</h3><ul><li><code>&lt;U> CompletableFuture&lt;U> thenApply(Function&lt;? super T,? extends U> fn)</code><ul><li>当 CompletableFuture 完成时，将结果传递给提供的函数。</li></ul></li><li><code>&lt;U> CompletableFuture&lt;U> thenApplyAsync(Function&lt;? super T,? extends U> fn)</code><ul><li>异步地应用一个函数到 CompletableFuture 的结果上。</li></ul></li><li><code>&lt;U> CompletableFuture&lt;U> thenApplyAsync(Function&lt;? super T,? extends U> fn, Executor executor)</code><ul><li>在指定的 Executor 中异步地应用一个函数到 CompletableFuture 的结果上。</li></ul></li></ul><h3 id=消费结果的方法>消费结果的方法</h3><ul><li><code>CompletableFuture&lt;Void> thenAccept(Consumer&lt;? super T> action)</code><ul><li>当 CompletableFuture 完成时，给定的动作会被执行，消费 CompletableFuture 的结果。</li></ul></li><li><code>CompletableFuture&lt;Void> thenAcceptAsync(Consumer&lt;? super T> action)</code><ul><li>异步地消费 CompletableFuture 的结果。</li></ul></li><li><code>CompletableFuture&lt;Void> thenAcceptAsync(Consumer&lt;? super T> action, Executor executor)</code><ul><li>在指定的 Executor 中异步地消费 CompletableFuture 的结果。</li></ul></li></ul><h3 id=组合-completablefuture-的方法>组合 CompletableFuture 的方法</h3><ul><li><code>&lt;U,V> CompletableFuture&lt;V> thenCombine(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T,? super U,? extends V> fn)</code><ul><li>当两个 CompletionStage 都正常完成时，将它们的结果传递给提供的函数。</li></ul></li><li><code>&lt;U,V> CompletableFuture&lt;V> thenCombineAsync(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T,? super U,? extends V> fn)</code><ul><li>异步地组合两个 CompletionStage 的结果，并应用函数。</li></ul></li><li><code>&lt;U,V> CompletableFuture&lt;V> thenCombineAsync(CompletionStage&lt;? extends U> other, BiFunction&lt;? super T,? super U,? extends V> fn, Executor executor)</code><ul><li>在指定的 Executor 中异步地组合两个 CompletionStage 的结果，并应用函数。</li></ul></li></ul><h3 id=异常处理的方法>异常处理的方法</h3><ul><li><code>CompletableFuture&lt;T> exceptionally(Function&lt;Throwable, ? extends T> fn)</code><ul><li>当 CompletableFuture 完成异常时，提供的函数将被调用，可以返回替代的结果。</li></ul></li><li><code>&lt;U> CompletableFuture&lt;U> handle(BiFunction&lt;? super T, Throwable, ? extends U> fn)</code><ul><li>当 CompletableFuture 完成时（无论正常还是异常），提供的函数都会被调用，并允许返回结果或抛出异常。</li></ul></li><li><code>&lt;U> CompletableFuture&lt;U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U> fn)</code><ul><li>异步地处理 CompletableFuture 的完成（无论正常还是异常）。</li></ul></li><li><code>&lt;U> CompletableFuture&lt;U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U> fn, Executor executor)</code><ul><li>在指定的 Executor 中异步地处理 CompletableFuture 的完成（无论正常还是异常）。</li></ul></li></ul><blockquote><p><strong>并行——使用流还是CompletableFutures？</strong></p><ul><li>如果你进行的是计算密集型的操作，并且没有I/O，那么推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有的线程都是计算密集型的，那就没有必要创建比处理器核数更多的线程）。</li><li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。****</li></ul></blockquote><h2 id=新的日期和时间api>新的日期和时间API</h2><h3 id=localdate>LocalDate</h3><ul><li><strong>内容</strong>：表示不带时间的日期，例如 <code>2023-03-30</code>。</li><li>常用API<ul><li><code>now()</code>：获取当前日期。</li><li><code>of(year, month, day)</code>：创建一个指定年月日的日期。</li><li><code>plusDays(long daysToAdd)</code>、<code>minusDays(long daysToSubtract)</code>：日期加减操作。</li><li><code>getDayOfWeek()</code>、<code>getMonth()</code>、<code>getYear()</code>：获取日期的各个部分。</li></ul></li></ul><h3 id=localtime>LocalTime</h3><ul><li><strong>内容</strong>：表示不带日期的时间，例如 <code>10:15:30</code>。</li><li>常用API<ul><li><code>now()</code>：获取当前时间。</li><li><code>of(hour, minute, second)</code>：创建一个指定时分秒的时间。</li><li><code>plusHours(long hoursToAdd)</code>、<code>minusHours(long hoursToSubtract)</code>：时间加减操作。</li><li><code>getHour()</code>、<code>getMinute()</code>、<code>getSecond()</code>：获取时间的各个部分。</li></ul></li></ul><h3 id=instant>Instant</h3><ul><li><strong>内容</strong>：表示时间线上的一个瞬时点，它是以 Unix 时间戳的形式来存储的。</li><li>常用API<ul><li><code>now()</code>：获取当前的瞬时点。</li><li><code>ofEpochMilli(long epochMilli)</code>：根据 Unix 时间戳创建 Instant 实例。</li><li><code>plusMillis(long millisToAdd)</code>、<code>minusMillis(long millisToSubtract)</code>：瞬时点的加减操作。</li></ul></li></ul><h3 id=duration>Duration</h3><ul><li><strong>内容</strong>：表示两个时刻之间的时间量，以秒和纳秒为单位。</li><li>常用API<ul><li><code>between(Temporal startInclusive, Temporal endExclusive)</code>：计算两个时间点之间的 Duration。</li><li><code>ofDays(long days)</code>、<code>ofHours(long hours)</code>、<code>ofMinutes(long minutes)</code>：创建指定时间长度的 Duration。</li><li><code>plus(Duration duration)</code>、<code>minus(Duration duration)</code>：Duration 的加减操作。</li></ul></li></ul><h3 id=period>Period</h3><ul><li><strong>内容</strong>：表示两个日期之间的年月日的时间量。</li><li>常用API<ul><li><code>between(LocalDate startDateInclusive, LocalDate endDateExclusive)</code>：计算两个日期之间的 Period。</li><li><code>ofYears(int years)</code>、<code>ofMonths(int months)</code>、<code>ofDays(int days)</code>：创建指定时间长度的 Period。</li><li><code>plus(Period period)</code>、<code>minus(Period period)</code>：Period 的加减操作。</li></ul></li></ul><hr><h1 id=附录>附录</h1><h2 id=常用的函数式接口>常用的函数式接口</h2><div class=table-wrapper><table><thead><tr><th>接口名</th><th>方法签名</th><th>用途</th><th>其他方法</th></tr></thead><tbody><tr><td><code>Consumer&lt;T></code></td><td><code>void accept(T t)</code></td><td>接受单个输入参数并且不返回结果的操作（消费者）。</td><td>N/A</td></tr><tr><td><code>Supplier&lt;T></code></td><td><code>T get()</code></td><td>无需输入参数，返回一个结果。</td><td>N/A</td></tr><tr><td><code>Function&lt;T, R></code></td><td><code>R apply(T t)</code></td><td>接受一个输入参数，返回一个结果。</td><td><code>default &lt;V> Function&lt;V, R> compose(Function&lt;? super V, ? extends T> before)</code><br><code>default &lt;V> Function&lt;T, V> andThen(Function&lt;? super R, ? extends V> after)</code><br><code>static &lt;T> Function&lt;T, T> identity()</code></td></tr><tr><td><code>Predicate&lt;T></code></td><td><code>boolean test(T t)</code></td><td>确定类型为T的对象是否满足某约束，并返回boolean值。</td><td><code>default Predicate&lt;T> and(Predicate&lt;? super T> other)</code><br><code>default Predicate&lt;T> negate()</code><br><code>default Predicate&lt;T> or(Predicate&lt;? super T> other)</code></td></tr><tr><td><code>BiConsumer&lt;T,U></code></td><td><code>void accept(T t, U u)</code></td><td>接受两个输入参数的操作，并且不返回任何结果。</td><td>N/A</td></tr><tr><td><code>BiFunction&lt;T,U,R></code></td><td><code>R apply(T t, U u)</code></td><td>接受两个输入参数的函数，并且返回一个结果。</td><td>N/A</td></tr><tr><td><code>UnaryOperator&lt;T></code></td><td>继承自Function</td><td>一种特殊的Function，输入参数类型和返回类型相同。</td><td><code>static &lt;T> UnaryOperator&lt;T> identity()</code></td></tr><tr><td><code>BinaryOperator&lt;T></code></td><td>继承自BiFunction</td><td>一种特殊的BiFunction，两个输入参数和返回类型相同。</td><td>N/A</td></tr></tbody></table></div><h2 id=optional-类主要方法>Optional 类主要方法</h2><div class=table-wrapper><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>empty()</code></td><td>创建一个空的 <code>Optional</code> 实例。</td></tr><tr><td><code>of(T value)</code></td><td>创建一个包含非空值的 <code>Optional</code> 实例。如果 <code>value</code> 为 <code>null</code>，则抛出 <code>NullPointerException</code>。</td></tr><tr><td><code>ofNullable(T value)</code></td><td>创建一个 <code>Optional</code> 实例，如果指定的值为 <code>null</code>，则返回一个空的 <code>Optional</code>。</td></tr><tr><td><code>isPresent()</code></td><td>如果值存在且非空，则返回 <code>true</code>；否则返回 <code>false</code>。</td></tr><tr><td><code>isEmpty()</code></td><td>Java 11 中引入，如果值不存在或为空，则返回 <code>true</code>；否则返回 <code>false</code>。</td></tr><tr><td><code>get()</code></td><td>如果值存在，则返回该值；否则抛出 <code>NoSuchElementException</code>。</td></tr><tr><td><code>ifPresent(Consumer&lt;? super T> action)</code></td><td>如果值存在，执行给定的操作。</td></tr><tr><td><code>ifPresentOrElse(Consumer&lt;? super T> action, Runnable emptyAction)</code></td><td>Java 9 中引入，如果值存在，执行给定的操作；否则执行另一个操作。</td></tr><tr><td><code>orElse(T other)</code></td><td>如果有值则返回该值，否则返回一个默认值。</td></tr><tr><td><code>orElseGet(Supplier&lt;? extends T> other)</code></td><td>如果有值则返回该值，否则返回一个由 <code>Supplier</code> 接口生成的值。</td></tr><tr><td><code>orElseThrow()</code></td><td>如果有值则返回该值，否则抛出 <code>NoSuchElementException</code>。</td></tr><tr><td><code>orElseThrow(Supplier&lt;? extends X> exceptionSupplier)</code></td><td>如果有值则返回该值，否则抛出由提供的 <code>Supplier</code> 接口生成的异常。</td></tr><tr><td><code>filter(Predicate&lt;? super T> predicate)</code></td><td>如果有值且满足给定的条件，则返回包含该值的 <code>Optional</code>；否则返回一个空的 <code>Optional</code>。</td></tr><tr><td><code>map(Function&lt;? super T,? extends U> mapper)</code></td><td>如果有值，则对该值执行给定的映射函数，并返回一个 <code>Optional</code> 类型的结果。</td></tr><tr><td><code>flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U>> mapper)</code></td><td>如果有值，则将提供的 <code>Optional</code> 映射函数应用于该值，否则返回一个空的 <code>Optional</code>。</td></tr><tr><td><code>stream()</code></td><td>Java 9 中引入，如果有值则返回仅包含该值的顺序 <code>Stream</code>，否则返回一个空的 <code>Stream</code>。</td></tr></tbody></table></div><h2 id=pecs原则>PECS原则</h2><p>一个好的经验法则是所谓的PECS原则（&ldquo;Producer Extends, Consumer Super&rdquo;），由Joshua Bloch提出：</p><ul><li>如果你需要一个<strong>提供者（Producer）</strong>，即希望从泛型数据类型中读取数据，使用<code>extends</code>。</li><li>如果你需要一个<strong>消费者（Consumer）</strong>，即希望写入数据到泛型数据类型中，使用<code>super</code>。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a>
<a href=/tags/note/>Note</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-ND</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css integrity="sha256-J+iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s=" crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js integrity="sha256-InsNdER1b2xUewP+pKCUJpkhiqwHgqiPXDlIk7GzBu4=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI=" crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://unpkg.com/@waline/emojis@1.0.1/weibo"],lang:"zh-cn",locale:{admin:"Admin",placeholder:null},requiredMeta:["name","email","url"],serverURL:"https://hiwik-waline.vercel.app/"})</script><footer class=site-footer><section class=copyright>&copy;
2024 Hong Sikun</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.22.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js integrity=sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css integrity=sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE crossorigin=anonymous><script>NProgress.start(),document.addEventListener("readystatechange",()=>{document.readyState==="interactive"&&NProgress.inc(.8),document.readyState==="complete"&&NProgress.done()})</script></body></html>